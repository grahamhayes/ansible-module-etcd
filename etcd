#!/usr/bin/python
# -*- coding: utf-8 -*-

# (c) 2014, Taneli Lepp√§ <taneli@crasman.fi>
#
# This file is part of Ansible (sort of)
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.


ANSIBLE_METADATA = {'status': ['preview'],
                    'supported_by': 'community',
                    'version': '0.1'}

DOCUMENTATION = """
---
module: etcd
short_description: Set and delete values from etcd
description:
  - Sets or deletes values in etcd.
  - Parent directories of the key will be created if they do not already exist.
version_added: "0.1"
author: Graham Hayes
notes:
  - Supports check mode.
  - Initially based on https://github.com/devo-ps/ansible-addons
  - Modified from https://github.com/modcloth-labs/ansible-module-etcd
requirements:
  - requests >= 2.4
  - python-etcd >= 0.3.2
options:
  state:
    description:
      - This will be the state of the key in etcd
      - after this module completes its operations.
    required: true
    choices: [present, absent]
    default: present
  hosts:
    description:
      - The etcd hosts to use, in a comma separated list of values, including the scheme
    required: false
    default: https://127.0.0.1:2379
  values:
    description:
      - A yaml dict of values to be applied (or removed) on the etcd service
    required: true
    default: null
  allow_redirect:
    description:
      - Etcd attempts to redirect all write requests to the etcd master
      - for safety reasons. If allow_redirect is set to false, such
      - redirection will not be allowed. In this case, the value for `host`
      - must be the etcd leader or this module will err.
    required: false
    default: true
"""

EXAMPLES = """
# set a value in etcd
- etcd:
    state: present
    hosts: https://10.100.0.101:2379,https://10.100.0.102:2379,https://10.100.0.103:2379
    ssl_cert: /etc/etcd/client.cert
    ssl_key: /etc/etcd/client.key
    ca_cert: /etc/etcd/ca.cert
    values:
      coreos.com:
        network:
          config: '{ "Network": "172.18.0.0/16", "Backend": {"Type": "host-gw"} }'
          subnets:
            172.18.6.0-24: '{"PublicIP":"10.100.0.151","BackendType":"host-gw"}'

# delete a value from etcd
- etcd:
    state: absent
    hosts: https://10.100.0.101:2379,https://10.100.0.102:2379,https://10.100.0.103:2379
    ssl_cert: /etc/etcd/client.cert
    ssl_key: /etc/etcd/client.key
    ca_cert: /etc/etcd/ca.cert
    values:
      coreos.com:
        network:
          subnets:
            172.18.6.0-24

"""

from ansible.module_utils.basic import AnsibleModule

try:
    import etcd
    etcd_found = True
except ImportError:
    etcd_found = False

try:
    import requests
    requests_found = True
except ImportError:
    requests_found = False

from urlparse import urlparse
import copy

def _extract_host_port_tuples(hosts):
    host_ports = []
    scheme = 'https'
    for host in hosts.split(','):
        parsed = urlparse(host)
        result = (parsed.hostname, parsed.port)
        host_ports.append(result)
        scheme = parsed.scheme
    return host_ports, scheme

def _extract_paths(values, output=[], prefix=[]):

    for key, item in values.iteritems():

        if type(item) == dict:
            new_prefix = copy.deepcopy(prefix)
            new_prefix.append(key)
            output = _extract_paths(item, output, new_prefix)
        else:
            new_prefix = copy.deepcopy(prefix)
            new_prefix.append(key)
            output.append((new_prefix, item))

    return output

def main():
    stack = []

    module = AnsibleModule(
        argument_spec=dict(
            state=dict(
                required=False,
                choices=[
                    'present', 'absent'
                ],
                default='present'
            ),
            allow_redirect=dict(
                required=False,
                default=True
            ),
            hosts=dict(
                required=False,
                default='http://127.0.0.1:2379'
            ),
            values=dict(required=False, default=None, type='dict'),
        ),
        supports_check_mode=True
    )

    if not etcd_found:
        module.fail_json(msg="the python etcd module is required")

    if not requests_found:
        module.fail_json(msg="the python requests module is required")

    state = module.params['state']
    hosts = module.params['hosts']
    ssl_cert = module.params['ssl_cert']
    ssl_key = module.params['ssl_key']
    ssl_ca_cert = module.params['ssl_ca_cert']


    hosts, scheme = _extract_host_port_tuples(hosts)
    values = module.params['values']

    extracted_paths = _extract_paths(values)

    kwargs = {
        "hosts": hosts,
        "protocol": scheme,
        "path": extracted_paths,
    }


    module.exit_json(**kwargs)

    if state == 'present' and not values:
        module.fail_json(msg='Values are required with state="present".')

    client = etcd.Client(**kwargs)

    change = False
    prev_value = None

    # attempt to get key
    try:
        prev_value = client.get(key).value
    except requests.ConnectionError:
        module.fail_json(msg="Can not connect to target.")
    except KeyError:
        prev_value = None
    except etcd.EtcdException as err:
        module.fail_json(msg="Etcd error: %s" % err)

    # handle check mode
    if module.check_mode:
        if ((state == 'absent' and prev_value is not None) or
                (state == 'present' and prev_value != value)):
                    change = True
        module.exit_json(changed=change)

    if state == 'present':
        stack = []
        dirname = os.path.dirname(key)

        while True:
            if dirname == "/":
                break
            else:
                stack.append(dirname)
            dirname = os.path.dirname(dirname)

        # ensure parent directories exist (like mkdir -p)
        while stack:
            d = stack.pop()
            try:
                client.get(d).value
            except requests.ConnectionError:
                module.fail_json(msg="Can not connect to target.")
            except KeyError:
                client.write(d, '', dir=True)
                prev_value = None
            except etcd.EtcdException as err:
                module.fail_json(msg="Etcd error: %s" % err)

        try:
            set_res = client.write(key, value)
            if set_res.newKey or prev_value != value:
                change = True
        except requests.ConnectionError:
            module.fail_json(msg="Can not connect to target.")
    elif state == 'absent':
        if prev_value is not None:
            change = True
            try:
                set_res = client.delete(key)
            except requests.ConnectionError:
                module.fail_json(msg="Can not connect to target.")

    results = {
        'changed': change,
        'value': value,
        'key': key
    }

    if prev_value != value:
        results['prev_value'] = prev_value

    module.exit_json(**results)

if __name__ == '__main__':
    main()
